# 프로그래밍과 논리 / 수학
1. 논리
 - logic: hard(논리)) vd soft(직관). 직관_논리적인 느낌만 but 논리적 오류 발생

 - 혹은: inclusive OR(둘다), Exclusive OR(둘중 하나)

 - 같은 표현이라도 논리가 다를 수 있다. 알고리즘은 hard logic으로 이해 필요
 - **가정이 거짓이라면 그 명제는 항상 참**
 - 대우명제가 참이면 기존명제도 참  
 - 결과가 참이라면 그 명제는 항상 참
 - 역(p,q바꾸기),이(p,q참거짓첸지),대우(역+이)
 - ^(and)_둘다참이어야 참, v(or)_하나만 참이면 참, xor(o 안에 들어간 +)_둘중 하나만 참일 때 참
 - 연산자 우선순위: ~>^,v>->,<->
 - 항진명제(항상 참),모순명제(항상 거짓),사건 명제(둘다 아님), 조건 명제(p->q), 쌍방 조건 명제(p<->q)
 - 진리표: p,q의 참,거짓에 따라 명제식의 참,거짓을 표로 나타낸 것
   xor: AvB - A^B
 -  이치: 과정의 순서가 올바르게 연결
 - 논리: 이야기의 이치
   - 논리학: **형식**. p이면 q이다(명제:T,F로 판단할 수 있는 문장)
    p q ~p (q->~p) p^(q->~p)
 - 수학적 귀납법 기본형: p(1)이 참이고 p(n)->p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참.
 ex) 
 ```py
 def sum(x):
   if x <= 0:
      return
   return x + sum(x-1)
 ```
  sum(1) == 1이고 sum(n)+n+1 == sum(n+1)이다.
 에서 p(n)이 정말로 참일 필요는 없음. p(n)->p(n+1)이 참임을 보이는 것 뿐
 이 부분은 영상 다시_
 - 수학적 귀납법의 강한 형태: p(1)이 참이고 p(1)^p(2)...^p(n)->p(n+1)이 참이면 p(n)은 머든 자연수 n에 대해서 참

 - 증명 시 가정이 거짓임을 보임으로서 증명 가능
*버블 소트의 증명:
증명 연습 부분
거꾸로 A: 전체 
랑 반전E: 하나라도 가 뭐지
 - 전제
    - 배중률: 무조건 T,F, 중간이 없는 것
    - 모순율: True 와 False 동시에 성립 x
 - 반대와 부정(모든 가능성을 포함)의 차이

   

   O(T(n)) = O(n)
2. 증명
 - 정확한 명제식으로 표현할 수 있는 것이어야만 함
 - p(n) -> p(n+1) 이 참임을 보일 떄 p(n)이 참인가는 다루지 않아도 됨. 명제 자체만.
 - 수학적 귀납법 연습, 상세한 증명
 
## 이진수
- k개의 비트를 사용하면 0부터 2^(k-1)까지 표현 가능
   - 어떤 값 n을 표현하기 위해서는 2^k-1>= n이 성립해야 함
   - 같은 의미로 k >= log(n+1) -> 약 log n 비트가 필요
      - 여기서 log n이란 2의 몇 승이 n이 되느냐, n을 표현하는 데 몇 비트가 필요하냐, 1로 시작해서 계속 두배를 할 때 몇 번 하면 n이 되는냐의 답, n을 1로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답
   - x = log n 일 때 x와 n을 비교하면 x가 더 작고 n이 커질수록 엄청나게 달라진다
      - 10진수로 표현하지 않는 이유_너무 커짐
