```py
N = int(input())
lst = [[0]*7 for _ in range(2)]
for n in range(4)
  lst[0][n] = N+n
  lst[1][7-n] = N-n
lst = str(lst)
print(*lst)
```
O log n
알고리즘에서 log의 밑수는 2
2의 몇 승이 되는 지 추정. 올림함  .
O(1) 보단 느리지만 유사한 성능
O(NlogN)_sort 은 O(logN)_이진탐색보다는 느리지만 비슷한 성능

16진수. 2진수를 더 가독성 있게 사용
2진수를 10진수로 변환시 연산 오래걸림
2진수를 16진수로 변환시 연산속도 매우빠름

윈도우 + r + calc
HEX 16진수
DEC 10진수
OCT 8진수
BIN 2진수

10진수 2로 나눈 나머지 거꾸로하면 2진수

2진수 16진수 변환은 연산이 없음. 라이브러리 사용이나 단순 암기

##비트연산
- 1bit: 0과 1을 표현하는 정보의 단위
- 1Byte: 8 bit를 묶어 1Byte라고 한다.
- 비트연산: 컴퓨터의 CPU는 0과 1로 다루어 동작. 내부적으로 비트연산을 사용해서
    덧셈 뺄셈등 진행
  - &:비트단위로 AND연산을 한다
    - 2진수에서 같은 것만 살림
  - |:비트단위로 or연산을 한다
    - 2진수에서 살릴 거 다 살림
  - ^:xor연산자. 같으면 0, 아니면 1  
    - xor 두번하면 원래 수로 돌아옴, 암호화에 사용
- 2진수_0b를 접두어
- 10진수_0x를 접두어
bin() 2진수로, hex()16진수로, int(,) 10진수로
 

  - '<<':피연산자의 비트 열을 왼쪽으로 이도ㅓㅇ
  - '>>':파연산자의 비트열을 오른쪽으로 이동
    - 1 << n : 2^n
    - i & (1<<n) : 같거나 작은 수? i의 n번 비트가 1인지 아닌지 확인할 수 있다.
    - 음수 표현 방법: 음수를 2의 보수로 관리. 맨 앞자리 bit는 음수 or 양수를 구분하는 비트
        - 뺄셈의 연산속도 굿, 0과 -0을 따로 취급하지 않기때문
        - MSB = 1(음수), 아니면 양수
        - 표현방법: 수를 모두 뒤집고 + 1
        - 2의 보수를 두번 취하면 원래의 값으로 돌아옴
  - Not 연산자
    - (~): 모든 비트를 반전시킨다
        - ~4는 -5
```python
N,M = map(int,input().split())
check = True
for n in range(1,N+1):
    if not (M & (1<<n)):
        check =False
if check == True:
    print('ON')
else:
    print('OFF')
```    
- 파이썬에서 실수 출력 방법
    - 파이썬은 f-string 문법을 지향
    - {t:.nf} n자리까지 반올림
    - 파이썬은 굉장히 넓은 범위의 실수 표현가능
    - +로 넘어가면 inf, -로 넘어가면 0으로 표현
    - print(0.1+0.1+0.1 == 0.3) #False
```python
t = 0.1
print(f'{t:.20f}')
```

- 소수점이 있는 10진수를 2진수로 변환할 때
  
   

##실수
근사값으로 저장

## 투포인트 알고리즘
-  a = 맨처음
-  b = 중간 + 1
-  loop{
-  a 출력 후 a += 1
-  b 출력 후 b += 1
-  }

## 재귀호출
- 반복문은 코드를 n번 반복
- 재귀호출은 n 중 반복문 만들기
- 함수 호출 시 int타입 객체를 전달하면 값만 복사된다
-  기저조건: 무한 재귀호출을 막는 것
## 완전탐색
- 순열: 서로 다른 N개에서 R개를 중복없이 순서를 고려하여 나열하는것
- 중복순열: 중복 가능 순열
    - 재귀호출을 할 때마다 이동경로를 흔적으로 남긴다
    - 가장 마지막 레벨에 도착했을 때  이동경로를 출력한다
    - print는 마지막 레벨에 도착했을 때 출력
    - 이동할 곳의 위치를 path리스트에 기록
```python
path = []

def KFC(x):
    if x == 2:
        print(path)
        return
    for i in range(3):
        path.append(i)
        KFC(x+1)
        path.pop()
KFC(0)
```    
- 중복을 취급하지 않는 순열 구현방법
    - 중복순열 코드를 작성한다
    - 중복을 제거하는 코드를 추가하면 순열 코드 됨
    
- 중복 제거 원리
    - 전역리스트를 사용하면 이미 선택했던 숫자인지 아닌지 구분할 수 있다
    -  이를 used,visited 배열이라고 함
    - 재귀호출을 하기 직전 이미 선택했던 숫자인지 검사하는 코드 필요
```python
used = [False, False, False] #브랜치 개수
path = []

def KFC(x):
    if x == 2:
        print(path)
        return
    for i in range(3):
        if used[i] == True:continue
        used[i] = True
        path.append(i)
        KFC(x+1)
        path.pop()
        used[i] = False
KFC(0)
```    