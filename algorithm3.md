## 알고리즘 설계 기법의 종류
- 완전 탐색
  - 배열: for문, while 문
  - 그래프(관계가 있는 데이터)
    - DFS,BFS
  
완전탐색을 구현하면 시간 or 메모리 초과가 되더라

- 상황마다 좋은 걸 고르자 (그리디)
  - 규칙 + 증명 -> 구현

- 큰 문제를 작은 문제로 나누어 부분적으로 해결하자(다이나믹 프로그래밍)
  - 분할정복과 다르게 작은 문제가 중복
  - 중복된 문제의 해답을 저장해놓고 재활용하자(메모이제이션)

- 큰 문제를 작은 문제로 나누어 부분적으로 해결하자(분할정복)
- 전체중 가능성 없는 것을 빼자(백트래킹)

인천 자취방 가스 끊기

## 분할정복
- 문제를 분할해서 해결
- 분할_나눌수 없을 때까지, 정복, 통합
  - 하나라도 틀리면 전체결과 잘못나옴
  - 비슷한 로직을 반복
  - 보통 재귀로 구현
  
### 병합 정렬
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 자료를 최소 단위의 문제까지 나눈 후에 병합하면서 차례대로 정렬하여 최종 결과를 얻어냄
- O(n log n)
- 이진이랑 비슷하게 가는데 나눠서 그 리스트를 다시 재귀. 다 돌리면 병합
- 병합 시에는 크기 비교
- 멀티코어 CPU 나 다수의 프로세서에서 정렬 알고리즘을 병렬화하기위해 사용

### 퀵 정렬
- 분할할 떄 기준 아이템 중심으로 분할, 병합은 필요 x
- 평균적으로 효율 개좋음
- 호아 파티션 알고리즘
  - 가운데로 위치시킨 p(피봇)값보다 큰 값은 오른쪽, 작은 값들은 왼쪽 집합에 위치
  - 피봇값은 왼쪽 끝 오른쪽 끝 임의의 세 값중에 중간값
  - i는 가다가 큰값 만나면 정지, j는 반대에서 오다가 작은값 만나면 정지. 교환.
  - 최종 정지한 위치의 값과 피봇값 교환
- 로무토_별로임

- 매우 큰 입력 데이터에 대해서 좋은 성능

- 근데 sort()는 nlog n 이 보장됨. 그냥 sort()써라


### 이진 검색
- 자료는 정렬된 상태여야됨.
```py
arr = [324,32,22114,16,48,93,422,21,316]
arr.sort()
#반복문 버전
def binartSearch(target):
  # 제일 왼쪽, 오른쪽 인덱스 구하기
  low = 0
  high = len(arr) - 1

  # 해당 숫자를 찾으면 종료
  # 더 이상 쪼갤 수 없을 때까지
  while low <= high:
    mid = (low+high)//2

    # 가운데 숫자가 정답이면 종료
    if arr[mid] == target:
      return mid
    elif arr[mid] > target:
      high = mid - 1
    elif arr[mid] < target:
      low = mid + 1
  return -1 
print(binarySearch(21))

# 재귀함수버전
def bibinarySearch(low,high, target):
  #기저조건(언제까지 재귀가 반복되어야 할까)
  if low > high:
    return -1
  
  #다음 재귀 들어가기 전엔 무엇을 해야할까
  #정답 판별
  mid = (low+high)//2
  if target == arr[mid]:
    return mid
  
  #다음 재귀 함수 호출 (파라미터 생각 잘하기)
  if target < arr[mid]:
    return binartSearch(low, mid -1, target)
  else:
    return binarySearch(mid+1, high, target)
  #재귀 함수에서 돌아왔을 때ㅔ 어떤 작업을 해야할까
  #이진 검색에서는 없다.


```

lower bound, upper bound.